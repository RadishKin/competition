#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightEnc,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,leftEnc,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           RBdrive,       tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           RFdrive,       tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           LBdrive,       tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port5,           LFdrive,       tmotorVex393_MC29, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"


void pre_auton(){
  bStopTasksBetweenModes = true;
}
void moveAuton(int speed, int distance){

	SensorValue[leftEnc] = 0;
	SensorValue[rightEnc] = 0;
	while(abs(SensorValue[leftEnc]) < distance){
		motor[LBdrive] = motor[LFdrive] = motor[RBdrive] = motor[RFdrive] = speed;
	}
}
void moveAutonTurn(int rightSpeed, int leftSpeed, int distance){
	SensorValue[leftEnc] = 0;
	SensorValue[rightEnc] = 0;
	while(abs(SensorValue[leftEnc]) < distance){
		motor[LBdrive] = motor[LFdrive] = leftSpeed;
		motor[RBdrive] = motor[RFdrive] = rightSpeed;
	}
}
void moveAutonStop(int speed){
	motor[LBdrive] = motor[LFdrive] = motor[RFdrive] = motor[RBdrive] = speed;
}

task autonomous(){
	//AutonomousCodePlaceholderForTesting();
	moveAuton(63, 1411);
	moveAutonTurn(63, -63, 1411);
	moveAutonStop(0);
}

task usercontrol(){
	while (true){
		motor[LFdrive] = vexRT[Ch3];
    motor[LBdrive] = vexRT[Ch3];
    motor[RFdrive] = vexRT[Ch2];
    motor[RBdrive] = vexRT[Ch2];
	}
}
